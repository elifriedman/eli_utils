# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/plotting.ipynb.

# %% auto 0
__all__ = ["imshow", "image_grid", "draw_keypoints"]

# %% ../notebooks/plotting.ipynb 2
import cv2
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from pathlib import Path
import json
from .io import load_json


# %% ../notebooks/plotting.ipynb 3
def imshow(im, figsize=(9, 9), ticks=False, **kwargs):
    plt.figure(figsize=figsize)
    if ticks is False:
        plt.xticks([])
        plt.yticks([])
    plt.imshow(im, **kwargs)


def image_grid(images, shape: tuple[int, int] = None, figsize=(18, 9), no_space: bool = True, **kwargs):
    num_images = len(images)
    if shape is None:
        shape = (1, num_images) if num_images < 8 else (num_images, 1)
    assert num_images <= np.prod(shape), f"You have more images than your shape would allow: {num_images=}, {shape=}"
    fig = plt.figure(figsize=figsize, **kwargs)
    fig.patch.set_visible(False)  # make whitespace transparent
    fig.subplots_adjust(wspace=0, hspace=0)
    with_space_but_same_size_plots = not no_space
    if with_space_but_same_size_plots:
        fig.set_layout_engine(layout="compressed")
    rows, columns = shape
    for x in range(rows):
        for y in range(columns):
            i = x * columns + y
            ax = fig.add_subplot(shape[0], shape[1], i+1)
            if i < len(images):
                ax.imshow(images[i], **kwargs)
            ax.set_xticks([])
            ax.set_yticks([])


# %% ../notebooks/plotting.ipynb 4
def draw_keypoints(image, keypoints, size=3, color=(255, 0, 0)):
    image = image.copy()
    for x, y in keypoints:
        x = int(x)
        y = int(y)
        image[x - size : x + size, y - size : y + size] = color
    return image


# %% ../notebooks/plotting.ipynb 5
def view_in_fiftyone(
    paths: list[str],
    dicts: list[dict] = None,
    dataset: str = "tmp",
    persistent=False,
    address="0.0.0.0",
    port=None,
    wait=False,
):
    import fiftyone as fo

    if dicts is None:
        dicts = [{}] * len(paths)
    assert len(paths) == len(dicts), f"{len(paths)} != {len(dicts)}"
    dataset = fo.Dataset(dataset, overwrite=True, persistent=persistent)
    for path, data in zip(paths, dicts):
        if isinstance(data, str) or isinstance(data, Path):
            data = load_json(data)
        sample = fo.Sample(path)
        sample.update_fields(data)
        dataset.add_sample(sample)
    session = fo.Session(dataset=dataset, address=address, port=port)
    if wait is True:
        try:
            session.wait(-1)
        except KeyboardInterrupt:
            pass
    return session
